---
path: /build-a-coding-blog-with-mdx-and-gatsby-2019
date: 2019-12-31
title: Build a coding blog from scratch with Gatsby and MDX
tags:
  ['information', 'learning', 'gatsby', 'guide', 'mdx', 'markdown']
published: true
cover: ./cover.jpg
coverCredit: Photo by SpaceX on Unsplash
---

I have been using Gatsby since [v0 May 2017], at that time it was a
template I cloned and used happily. It was called Lumen and was just
what I needed at the time.

Over the years I have made my own [Progressive Disclosure of
Complexity] with Gatsby to where I am now.

## What we're going to build

We're going to build a developer blog with MDX support for some react
components in Markdown goodness.

## Also:

- Basic styling with styled-components
- cover images for the posts
- auto link headers
- SEO component
- RSS Feed
- Offline Support

## Who is this for?

People that may have used Gatsby before as a template and now want to
get more involved in how to make changes.

If you want to use styled-components in an app.

## Requirements

We're going to need a basic web development setup: node, terminal
(bash, zsh or fish) and a text editor.

I do like to use [codesandbox.io] for these sort of guides to reduce
the barrier to entry but in this case I have found there are some
limitations with starting out from scratch on [codesandbox.io] which
doesn't make this possible.

I have made a guide on getting set up for web development with
[Windows Web-Dev Bootstrap] and covered the same process in [Ubuntu as
well].

Ok? Let's get started!

<!-- TOC -->

- [Hello World](#hello-world)
  - [basic hello world](#basic-hello-world)
- [Add content](#add-content)
- [Gatsby config API](#gatsby-config-api)
- [Plugins](#plugins)
  - [Gatsby source filesystem](#gatsby-source-filesystem)
  - [Gatsby plugin MDX](#gatsby-plugin-mdx)
- [Query data from GraphQL](#query-data-from-graphql)
- [Site Metadata](#site-metadata)
- [Site metadata hook](#site-metadata-hook)
- [Styling](#styling)
- [Layout](#layout)
- [Index page posts query](#index-page-posts-query)
- [Slugs and Paths](#slugs-and-paths)
- [Previous and Next](#previous-and-next)
- [Code Blocks](#code-blocks)
- [Cover Image](#cover-image)
- [i11n](#i11n)
- [SEO](#seo)
- [Commenting](#commenting)
- [Links](#links)

<!-- /TOC -->

## Hello World

Let's kick this off with the Gatsby 'hello world', we'll need to
initialise the project with:

```bash
npm init -y
git init
```

I suggest that we commit this code to a git repository, so we should
start with a `.gitignore` file.

```bash
touch .gitignore

echo "# Project dependencies
.cache
node_modules

# Build directory
public

# Other
.DS_Store
yarn-error.log" > .gitignore
```

Ok now is a good time to do a `git init` and if you're using VSCode
you'll see the changes reflected in the sidebar.

### basic hello world

Ok a Gatsby hello world, let's get started with the bare minimum!
Install the following:

```bash
yarn add gatsby react react-dom
```

We're going to need to create a pages directory and add an index file.
We can do that in the terminal by typing the following:

```bash
# -p is to create parent directories too if needed
mkdir -p src/pages
touch src/pages/index.js
```

Ok, now we can commence the hello word incantation! In the newly
created `index.js` enter the following:

```jsx
import React from 'react';

export default () => {
  return <h1>Hello World!</h1>;
};
```

Now we need to add the Gatsby develop script to the `package.json`
file, `-p` specifies what port you want to run the project on and `-o`
opens a new tab on your default browser, so in this case
`localhost:9988`:

```json
"dev": "gatsby develop -p 9988 -o"
```

Ok it's time to run the code! From the terminal type the npm script
command we just created:

```bash
yarn dev
```

> Note I'm using Yarn for installing all my dependencies and running
> scripts, if you prefer you can use npm just bear in mind that the
> content on here uses yarn, so swap out commands where needed

And with that the "Hello World" incantation is complete 🧙!

## Add content

Ok, now we have the base our blog we're going to want to add some
content, first up I'm going to get the convention out of the way. I
like my date format a logical way, the most logical way for a date
format is **YYYYMMDD**, fight me!

So we're going to structure our posts content in years, in each one of
those we're going to have another folder relating to the post with the
(correct) date format for the beginning of the file followed by the
title of the post. You could drill into this further if you like by
separating out months and days depending on the volume of posts going
this may be a good approach. In this case we're going to go with the
convention I've detailed already.

```bash
# create multiple directories using curly braces
mkdir -p posts/2019/{2019-06-01-hello-world,2019-06-10-second-post,2019-06-20-third-post}
touch posts/2019/2019-06-01-hello-world/index.mdx
touch posts/2019/2019-06-10-second-post/index.mdx
touch posts/2019/2019-06-20-third-post/index.mdx
```

Ok that's our posts set up now we need to add some content to them,
each file we have in here should have frontmatter. Frontmatter is a
way to assign properties to the contents, in this case a `title`,
published `date` and a `published` flag (`true` or `false`).

```md
---
title: Hello World - from mdx!
date: 2019-06-01
published: true
---

# h1 Heading

My first post!!

## h2 Heading

### h3 Heading
```

```md
---
title: Second Post!
date: 2019-06-10
published: true
---

This is my second post!

#### h4 Heading

##### h5 Heading

###### h6 Heading
```

```md
---
title: Third Post!
date: 2019-06-20
published: true
---

This is my third post!

> with a block quote!
```

## Gatsby config API

Ok, now we're going to configure Gatsby so that it can read our super
awesome content we just created. So first up we need to create a the
`gatsby-config.js` file, in the terminal create the file:

```bash
touch gatsby-config.js
```

## Plugins

And now we can add the plugins Gatsby needs to use for sourcing and
displaying the the files we just created.

### Gatsby source filesystem

The [gatsby-source-filesystem] collects the files on the local
filesystem for use in Gatsby once configured.

### Gatsby plugin MDX

The [gatsby-plugin-mdx] is what will be allowing us to write JSX in
our Markdown documents and the heart of how the content is displayed
in the blog.

Now is a good time to also add in dependent packages for the Gatsby
plugin MDX which are `@mdx-js/mdx` and `@mdx-js/react`.

In the terminal install the dependencies:

```bash
yarn add gatsby-plugin-mdx @mdx-js/mdx @mdx-js/react gatsby-source-filesystem
```

```bash
touch gatsby-config.js
```

Now its time to configure `gatsby-config.js`:

```js
module.exports = {
  siteMetadata: {
    title: `The Localhost Blog`,
    description: `This is my coding blog where I write about my coding journey.`,
  },
  plugins: [
    {
      resolve: `gatsby-plugin-mdx`,
      options: {
        extensions: [`.mdx`, `.md`],
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/posts`,
        name: `posts`,
      },
    },
  ],
};
```

## TODO add 404 page

## Query data from GraphQL

Ok now we can see what the [gatsby-source-filesystem] and
[gatsby-plugin-mdx] have done for us. We can now go to the Gatsby
GraphQL GraphiQL explorer and check out the data:

```graphql
{
  allMdx {
    nodes {
      frontmatter {
        title
        date
      }
    }
  }
}
```

## Site Metadata

When you want to reuse common pieces of data across the site (for
example, your site title), you can store that data in `siteMetadata`,
we touched on this when defining the `gatsby-config.js`, now we're
going to separate this out from the `module.exports`, why? It will be
nicer to reason about once the config is filled with plugins. At the
top of `gatsby-config.js` add a new object variable for the site
metadata:

```js
const siteMetadata = {
  title: `The Localhost Blog`,
  description: `This is my coding blog where I write about my coding journey.`,
};
```

Now let's query the Site Metadata with GraphQL.

```graphql
{
  site {
    siteMetadata {
      title
      description
    }
  }
}
```

## Site metadata hook

Ok, so, that's cool n' all but how am I meant to use it? Well let's do
some of the code stuff and make a React hook so we can get our site
data in any component we need it.

Let's create a folder to keep all our hooks in and create a file for
our hook, in the terminal do:

```bash
mkdir src/hooks
touch src/hooks/useSiteMetadata.js
```

Ok, and in our newly created file were going to use the Gatsby
`useStaticQuery` hook to make our own hook:

```js
import { graphql, useStaticQuery } from 'gatsby';

export const useSiteMetadata = () => {
  const { site } = useStaticQuery(
    graphql`
      query SITE_METADATA_QUERY {
        site {
          siteMetadata {
            title
            description
          }
        }
      }
    `
  );
  return site.siteMetadata;
};
```

Now we can use this hook anywhere in our site, so let's do that now in
`src/pages/index.js`:

```jsx
import React from 'react';
import { useSiteMetadata } from '../hooks/useSiteMetadata';

export default () => {
  const { title, description } = useSiteMetadata();
  return (
    <>
      <h1>{title}</h1>
      <p>{description}</p>
    </>
  );
};
```

## Styling

We're going to use styled-components for styling, styled-components
(for me) help with scoping styles in your components. Let's go over
the basics now.

### install styled-components

```bash
yarn add gatsby-plugin-styled-components styled-components babel-plugin-styled-components
```

So, what was all that I just installed?

The babel plugin is for automatic naming of components to help with
debugging.

The Gatsby plugin is for built-in server-side rendering support.

### Configure

Ok, with that detailed explanation out of the way let's configure them
in `gatsby-config.js`:

```js
const siteMetadata = {
  title: `The Localhost Blog`,
  description: `This is my coding blog where I write about my coding journey.`,
};

module.exports = {
  siteMetadata: siteMetadata,
  plugins: [
    `gatsby-plugin-styled-components`,
    {
      resolve: `gatsby-plugin-mdx`,
      options: {
        extensions: [`.mdx`, `.md`],
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: { path: `${__dirname}/posts`, name: `posts` },
    },
  ],
};
```

Ok, so let's go over a styled component, in `index.js` we're going to
`import styled from 'styled-components'` and create a `StyledH1`
variable.

So, we're using the variable to wrap our `{title}` that we're
destructuring from the `useSiteMetadata` hook we made previously.

For this example let's make it the now iconic Gatsby `rebeccapurple`.

```jsx
import React from 'react';
import styled from 'styled-components';
import { useSiteMetadata } from '../hooks/useSiteMetadata';

const StyledH1 = styled.h1`
  color: rebeccapurple;
`;

export default () => {
  const { title, description } = useSiteMetadata();
  return (
    <>
      <StyledH1>{title}</StyledH1>
      <p>{description}</p>
    </>
  );
};
```

That is styled-components on a very basic level, basically create the
styling you want for your page elements you're creating in the JSX.

## Layout

Gatsby doesn't apply any layouts by default but instead uses the way
you can compose React components for the layout, meaning it's up to
you how you want to layout what your building with Gatsby. In this
guide were going to initially create a basic layout component that
we'll add to as we go along. For more detail on layout components take
a look at the Gatsby [layout components] page.

Ok, so now we're going to refactor the home page
(`src/pages/index.js`) a little and make some components for our blog
layout and header. In the terminal create a components directory and a
`Header` and `Layout` component:

```bash
mkdir src/components
touch src/components/Header.js src/components/Layout.js
```

Now to move the title and description from `src/pages/index.js` to the
newly created `src/components/Header.js` component, destructuring
props for the `siteTitle` and `siteDescription`, we'll pass these from
the `Layout` component to here. We're going to add Gatsby Link to this
so users can click on the header to go back to the home page.

```jsx
import { Link } from 'gatsby';
import React from 'react';

export const Header = ({ siteTitle, siteDescription }) => (
  <Link to="/">
    <h1>{siteTitle}</h1>
    <p>{siteDescription}</p>
  </Link>
);
```

Now to the Layout component, this is going to be a basic wrapper
component for now, we're going to use our site metadata hook for the
title and description and pass them to the header component and return
the children of the wrapper (`Layout`).

```jsx
import React from 'react';
import { useSiteMetadata } from '../hooks/useSiteMetadata';
import { Header } from './Header';

export const Layout = ({ children }) => {
  const { title, description } = useSiteMetadata();
  return (
    <>
      <Header siteTitle={title} siteDescription={description} />
      {children}
    </>
  );
};
```

Now to add the slightest of styles for some alignment for
`src/components/Layout.js`, create an `AppStyles` styled component and
make it the main wrapper of our `Layout`.

```jsx
import React from 'react';
import styled from 'styled-components';
import { useSiteMetadata } from '../hooks/useSiteMetadata';
import { Header } from './Header';

const AppStyles = styled.main`
  width: 800px;
  margin: 0 auto;
`;

export const Layout = ({ children }) => {
  const { title, description } = useSiteMetadata();
  return (
    <AppStyles>
      <Header siteTitle={title} siteDescription={description} />
      {children}
    </AppStyles>
  );
};
```

Ok, now let's refactor our homepage (`src/pages/index.js`) with
`Layout`.

```jsx
import React from 'react';
import { Layout } from '../components/Layout';

export default () => {
  return (
    <>
      <Layout />
    </>
  );
};
```

## Index page posts query

Ok, now we can take a look at getting some of the posts we've created
add them to the index page of our blog. We're going to do that by
creating a graphql query to list out the posts by title, order by date
and add an excerpt of the post.

The query will look something like this:

```graphql
{
  allMdx {
    nodes {
      id
      excerpt(pruneLength: 250)
      frontmatter {
        title
        date
      }
    }
  }
}
```

If we put that into the GraphiQL GUI though you'll notice that the
posts aren't in any given order, so let's now add a sort to this we'll
also add in a filter for posts that are marked as published or not.

```graphql
{
  allMdx(
    sort: { fields: [frontmatter___date], order: DESC }
    filter: { frontmatter: { published: { eq: true } } }
  ) {
    nodes {
      id
      excerpt(pruneLength: 250)
      frontmatter {
        title
        date
      }
    }
  }
}
```

On the homepage (`src/pages/index.js`) we're going to use the query we
just put together to get a list of published posts in date order; add
the following to the `index.js` file:

```jsx
import { graphql } from 'gatsby';
import React from 'react';
import { Layout } from '../components/Layout';

export default ({ data }) => {
  return (
    <>
      <Layout>
        {data.allMdx.nodes.map(({ excerpt, frontmatter }) => (
          <>
            <h1>{frontmatter.title}</h1>
            <p>{frontmatter.date}</p>
            <p>{excerpt}</p>
          </>
        ))}
      </Layout>
    </>
  );
};

export const query = graphql`
  query SITE_INDEX_QUERY {
    allMdx(
      sort: { fields: [frontmatter___date], order: DESC }
      filter: { frontmatter: { published: { eq: true } } }
    ) {
      nodes {
        id
        excerpt(pruneLength: 250)
        frontmatter {
          title
          date
        }
      }
    }
  }
`;
```

Woah! WTF was all that yo!?

Ok, we're looping through the data passed into the component via the
GraphQL query. Gatsby `graphql` runs the query (`SITE_INDEX_QUERY`) at
runtime and gives us the results as props to our component via the
`data` prop.

## Slugs and Paths

Gatsby source filesystem will help with the creation of slugs (URL
paths for the posts we're creating) in Gatsby node we're going to
create the slugs for our posts.

First up we're going to need to create a `gatsby-node.js` file:

```bash
touch gatsby-node.js
```

This will create the file path (URL) for each of the blog posts.

We're going to be using the Gatsby Node API `onCreateNode` and
destructuring out `node`, `actions` and `getNode` for use in creating
the file locations and associated value.

```js
const { createFilePath } = require(`gatsby-source-filesystem`);

exports.onCreateNode = ({ node, actions, getNode }) => {
  const { createNodeField } = actions;
  if (node.internal.type === `Mdx`) {
    const value = createFilePath({ node, getNode });
    createNodeField({
      name: `slug`,
      node,
      value,
    });
  }
};
```

Now to help visualise some of the data being passed into the
components we're going to use [Dump.js] for debugging the data. Thanks
to Wes Bos for the super handy [Dump.js] component.

To get the component set up let's create a `Dump.js` file in our
`src\components` folder and copypasta the code from the linked GitHub
page.

```bash
touch /src/components/Dump.js
```

```jsx
import React from 'react';

const Dump = props => (
  <div
    style={{
      fontSize: 20,
      border: '1px solid #efefef',
      padding: 10,
      background: 'white',
    }}>
    {Object.entries(props).map(([key, val]) => (
      <pre key={key}>
        <strong style={{ color: 'white', background: 'red' }}>
          {key} 💩
        </strong>
        {JSON.stringify(val, '', ' ')}
      </pre>
    ))}
  </div>
);

export default Dump;
```

Now we can use the `Dump` component anywhere in our project. To
demonstrate let's use it with the index page `data` to see the output.

So in the `src/pages/index.js` we're going to import the Dump
component and pass in the `data` prop and see what the output looks
like.

```jsx
import { graphql } from 'gatsby';
import React from 'react';
import Dump from '../components/Dump';
import { Layout } from '../components/Layout';

export default ({ data }) => {
  return (
    <>
      <Layout>
        <Dump data={data} />
        {data.allMdx.nodes.map(({ excerpt, frontmatter }) => (
          <>
            <h1>{frontmatter.title}</h1>
            <p>{frontmatter.date}</p>
            <p>{excerpt}</p>
          </>
        ))}
      </Layout>
    </>
  );
};

export const query = graphql`
  query SITE_INDEX_QUERY {
    allMdx(
      sort: { fields: [frontmatter___date], order: DESC }
      filter: { frontmatter: { published: { eq: true } } }
    ) {
      nodes {
        id
        excerpt(pruneLength: 250)
        frontmatter {
          title
          date
        }
      }
    }
  }
`;
```

## Link Paths

Now we've created the paths we can link to them with Gatsby Link.
First we'll need to add the slug to our `SITE_INDEX_QUERY` Then we can
add gatsby `Link` to `src/pages/index.js`.

We're also going to create some styled-components for wrapping the
list of posts and each individual post as well.

```jsx
import { graphql, Link } from 'gatsby';
import React from 'react';
import styled from 'styled-components';
import { Layout } from '../components/Layout';

const IndexWrapper = styled.main``;

const PostWrapper = styled.div``;

export default ({ data }) => {
  return (
    <Layout>
      <IndexWrapper>
        {data.allMdx.nodes.map(
          ({ id, excerpt, frontmatter, fields }) => (
            <PostWrapper key={id}>
              <Link to={fields.slug}>
                <h1>{frontmatter.title}</h1>
                <p>{frontmatter.date}</p>
                <p>{excerpt}</p>
              </Link>
            </PostWrapper>
          )
        )}
      </IndexWrapper>
    </Layout>
  );
};

export const query = graphql`
  query SITE_INDEX_QUERY {
    allMdx(
      sort: { fields: [frontmatter___date], order: DESC }
      filter: { frontmatter: { published: { eq: true } } }
    ) {
      nodes {
        id
        excerpt(pruneLength: 250)
        frontmatter {
          title
          date
        }
        fields {
          slug
        }
      }
    }
  }
`;
```

## Adding a Blog Post Template

Now we have the links pointing to the blog posts we currently have no
file associated with the path, so clicking a link will give you a 404
and the built in gatsby 404 will list all the pages available in the
project, currently only the `/` index/homepage.

So, for each one of our blog posts we're going to use a template that
will contain, the information we need to make up our blog post. To
start let's create a `templates` directory and template file for that
with:

```bash
mkdir -p src/templates
touch src/templates/blogPostTemplate.js
```

For now we're going to scaffold out a basic template, we'll be adding
data to this shortly:

```jsx
import React from 'react';

export default () => {
  return (
    <>
      <p>post here</p>
    </>
  );
};
```

To populate the template we'll need to use Gatsby node to create our
pages.

Gatsby Node has many internal APIs available to us, for this example
we're going to be using the `createPages` API.

More details on Gatsby `createPages` API can be found on the Gatsby
docs, details here:
[https://www.gatsbyjs.org/docs/node-apis/#createPages](https://www.gatsbyjs.org/docs/node-apis/#createPages)

In our `gatsby-node.js` file we're going to add in the following in
addition to the `onCreateNode` export we did earlier.

```js
const { createFilePath } = require(`gatsby-source-filesystem`);
const path = require(`path`);

exports.createPages = ({ actions, graphql }) => {
  const { createPage } = actions;
  const blogPostTemplate = path.resolve(
    'src/templates/blogPostTemplate.js'
  );

  return graphql(`
    {
      allMdx {
        nodes {
          fields {
            slug
          }
          frontmatter {
            title
          }
        }
      }
    }
  `).then(result => {
    if (result.errors) {
      throw result.errors;
    }

    const posts = result.data.allMdx.nodes;

    // create page for each mdx file
    posts.forEach(post => {
      createPage({
        path: post.fields.slug,
        component: blogPostTemplate,
        context: {
          slug: post.fields.slug,
        },
      });
    });
  });
};

exports.onCreateNode = ({ node, actions, getNode }) => {
  const { createNodeField } = actions;
  if (node.internal.type === `Mdx`) {
    const value = createFilePath({ node, getNode });
    createNodeField({
      name: `slug`,
      node,
      value,
    });
  }
};
```

So the part that we need to pay particular attention to right now is
the `.forEach` loop where we're using the `createPage` function we
destructured from the `actions` object.

This is where we pass the data needed by `blogPostTemplate` we defined
earlier. We're going to be adding more to the `context` for post
navigation soon.

```js
// create page for each mdx node
posts.forEach(post => {
  createPage({
    path: post.fields.slug,
    component: blogPostTemplate,
    context: {
      slug: post.fields.slug,
    },
  });
});
```

Now we're going to take the context information passed to the
`blogPostTemplate.js` to make the blog post page.

This is similar to the `index.js` homepage whereas there's GraphQL
data used to create the page but in this instance the template uses a
variable (also known as a parameter or an identifier) so we can query
data specific to that given variable.

Let's quickly dig into that with a demo. In the GraphiQL GUI, let's
create a named query and define the variable we're going to pass in:

```graphql
query PostBySlug($slug: String!) {
  mdx(fields: { slug: { eq: $slug } }) {
    frontmatter {
      title
      date(formatString: "YYYY MMMM Do")
    }
  }
}
```

Here we're defining the variable as slug with the `$` denoting that
it's a variable, we also need to define the variable type as (in this
case) `String!` the exclamation after the type means that it has to be
a string being passed into the query.

Using `mdx` we're going to filter on `fields` where the `slug` matches
the variable being passed into the query.

Running the query now will show an error as there's no variable being
fed into the query. If you look to the bottom of the query pane you
should notice `QUERY VARIABLES`, click on that to bring up the
variables pane.

This is where you can add in one of the post paths we created earlier,
if you have your dev server up and running go to one of the posts and
take the path and paste it into the quotes `""` and try running the
query again.

```graphql
{
  "slug": "/2019/2019-06-20-third-post/"
}
```

Time to use that data to make the post, we're going to add `body` to
the query and have that at the bottom of our page file.

Right now we're going to add create a simple react component that will
display the data we have queried.

Destructuring the `frontmatter` and `body` from the GraphQL query,
we'll get the Title and the Data from the frontmatter object and wrap
the `body` in the `MDXRenderer`.

```jsx
import { graphql } from 'gatsby';
import { MDXRenderer } from 'gatsby-plugin-mdx';
import React from 'react';
import { Layout } from '../components/Layout';

export default ({ data }) => {
  const { frontmatter, body } = data.mdx;
  return (
    <Layout>
      <h1>{frontmatter.title}</h1>
      <p>{frontmatter.date}</p>
      <MDXRenderer>{body}</MDXRenderer>
    </Layout>
  );
};

export const query = graphql`
  query PostsBySlug($slug: String!) {
    mdx(fields: { slug: { eq: $slug } }) {
      body
      frontmatter {
        title
        date(formatString: "YYYY MMMM Do")
      }
    }
  }
`;
```

If you haven't done so already now would be a good time to restart
your dev server.

Now we can click on one of the post links and see our blog post
template in all it's basic glory!

## Previous and Next

Coolio! Now we have our basic ass blog where we can list available
post and click a link to see the full post in a predefined template.
Once you're in a post you have to navigate back to the home page to
pick out a new post to read. In this section we're going to work on
adding in some previous and next navigation.

Remember the `.forEach` snippet we looked at earlier? That's where
we're going to pass some additional context to the page by selecting
out the previous and next posts.

```js
// create page for each mdx node
posts.forEach((post, index) => {
  const previous =
    index === posts.length - 1 ? null : posts[index + 1];
  const next = index === 0 ? null : posts[index - 1];

  createPage({
    path: post.fields.slug,
    component: blogPostTemplate,
    context: {
      slug: post.fields.slug,
      previous,
      next,
    },
  });
});
```

So this should now match up with the query we have on the homepage
(`src/pages/index.js`) except we currently have no filter or sort
applied here so let's do that now in `gatsby-node.js` and apply the
same filters as on the homepage query:

```js
const { createFilePath } = require(`gatsby-source-filesystem`);
const path = require(`path`);

exports.createPages = ({ actions, graphql }) => {
  const { createPage } = actions;
  const blogPostTemplate = path.resolve(
    'src/templates/blogPostTemplate.js'
  );

  return graphql(`
    {
      allMdx(
        sort: { fields: [frontmatter___date], order: DESC }
        filter: { frontmatter: { published: { eq: true } } }
      ) {
        nodes {
          fields {
            slug
          }
          frontmatter {
            title
          }
        }
      }
    }
  `).then(result => {
    if (result.errors) {
      throw result.errors;
    }

    const posts = result.data.allMdx.nodes;

    // create page for each mdx node
    posts.forEach((post, index) => {
      const previous =
        index === posts.length - 1 ? null : posts[index + 1];
      const next = index === 0 ? null : posts[index - 1];

      createPage({
        path: post.fields.slug,
        component: blogPostTemplate,
        context: {
          slug: post.fields.slug,
          previous,
          next,
        },
      });
    });
  });
};

exports.onCreateNode = ({ node, actions, getNode }) => {
  const { createNodeField } = actions;
  if (node.internal.type === `Mdx`) {
    const value = createFilePath({ node, getNode });
    createNodeField({
      name: `slug`,
      node,
      value,
    });
  }
};
```

Now we will be able to expose the `previous` and `next` objects passed
in as context from Gatsby node.

We can destructure `previous` and `next` from `pageContext` and for
now pop them into our super handy `Dump` component to take a look at
their contents.

```jsx
import { graphql } from 'gatsby';
import { MDXRenderer } from 'gatsby-plugin-mdx';
import React from 'react';
import Dump from '../components/Dump';
import { Layout } from '../components/Layout';

export default ({ data, pageContext }) => {
  const { frontmatter, body } = data.mdx;
  const { previous, next } = pageContext;
  return (
    <Layout>
      <Dump previous={previous} />
      <Dump next={next} />
      <h1>{frontmatter.title}</h1>
      <p>{frontmatter.date}</p>
      <MDXRenderer>{body}</MDXRenderer>
    </Layout>
  );
};

export const query = graphql`
  query PostsBySlug($slug: String!) {
    mdx(fields: { slug: { eq: $slug } }) {
      body
      frontmatter {
        title
        date(formatString: "YYYY MMMM Do")
      }
    }
  }
`;
```

Add in previous and next navigation, this is a couple of ternary
operations, if the variable is empty then return `null` else render a
Gatsby `Link` component with the page slug and the frontmatter title:

```jsx
import { graphql, Link } from 'gatsby';
import { MDXRenderer } from 'gatsby-plugin-mdx';
import React from 'react';
import Dump from '../components/Dump';
import { Layout } from '../components/Layout';

export default ({ data, pageContext }) => {
  const { frontmatter, body } = data.mdx;
  const { previous, next } = pageContext;
  return (
    <Layout>
      <Dump previous={previous} />
      <Dump next={next} />
      <h1>{frontmatter.title}</h1>
      <p>{frontmatter.date}</p>
      <MDXRenderer>{body}</MDXRenderer>
      {previous === false ? null : (
        <>
          {previous && (
            <Link to={previous.fields.slug}>
              <p>{previous.frontmatter.title}</p>
            </Link>
          )}
        </>
      )}
      {next === false ? null : (
        <>
          {next && (
            <Link to={next.fields.slug}>
              <p>{next.frontmatter.title}</p>
            </Link>
          )}
        </>
      )}
    </Layout>
  );
};

export const query = graphql`
  query PostsBySlug($slug: String!) {
    mdx(fields: { slug: { eq: $slug } }) {
      body
      frontmatter {
        title
        date(formatString: "YYYY MMMM Do")
      }
    }
  }
`;
```

## Code Blocks

Now to add some syntax highlighting for adding code blocks to our blog
pages. To do that we're going to add dependencies for
[prism-react-renderer] and [react-live] and we'll also create the
files we're going to need to use them:

```bash
yarn add prism-react-renderer react-live
touch root-wrapper.js gatsby-ssr.js gatsby-browser.js
```

We'll come onto `react-live` soon for now we're going to get
`prism-react-render` up and running for syntax highlighting for any
code we're going to add to the blog, but before that we're going to go
over the root wrapper concept.

So, to change the rendering of a page element, such as a heading or a
code block we're going to need to use the `MDXProvider`, the
`MDXProvider` is a component we can use anywhere higher in the React
component tree than the MDX content we want to render.

Gatsby browser and a Gatsby SSR both have `wrapRootElement` available
to them and that is as high up the tree as we can get so we're going
to create the `root-wrapper.js` file and add out elements we want to
override there and import it into both `gatsby-browser.js` and
`gatsby-ssr.js` so we're not duplicating code.

Before we go any further I want to add that there is a top quality
[egghead.io playlist] resource for using MDX with Gatsby by Chris
[Chris Biscardi] there's a ton of useful information in there on MDX
in Gatsby.

Ok, first up we're going to import the `root-wrapper.js` file into
both `gatsby-browser.js` and `gatsby-ssr.js`, in both code modules
paste the following:

```js
import { wrapRootElement as wrap } from './root-wrapper';

export const wrapRootElement = wrap;
```

Ok, now we can work on the code that will be used in both modules. MDX
allows you to control the rendering of page elements in your markdown.
`MDXProvider` is used to give to give React components to override the
markdown page elements.

Quick demonstration, in `root-wrapper.js` add the following:

```jsx
import { MDXProvider } from '@mdx-js/react';
import React from 'react';

const components = {
  h2: ({ children }) => (
    <h2 style={{ color: 'rebeccapurple' }}>{children}</h2>
  ),
  'p.inlineCode': props => (
    <code style={{ backgroundColor: 'lightgray' }} {...props} />
  ),
};

export const wrapRootElement = ({ element }) => (
  <MDXProvider components={components}>{element}</MDXProvider>
);
```

We're now overriding any `h2` in our rendered markdown along with any
`code` blocks (that's words wrapped in `` `backticks` ``).

Ok, now for the syntax highlighting, let's create a post with a block
of code in it:

```bash
mkdir posts/2019-07-01-code-blocks
touch posts/2019-07-01-code-blocks/index.mdx
```

Paste in some content:

````markdown
---
title: Code Blocks
date: 2019-07-01
published: true
---

## Yes! Some code!

Here is the `Dump` component!

```jsx
import React from 'react';

const Dump = props => (
  <div
    style={{
      fontSize: 20,
      border: '1px solid #efefef',
      padding: 10,
      background: 'white',
    }}>
    {Object.entries(props).map(([key, val]) => (
      <pre key={key}>
        <strong style={{ color: 'white', background: 'red' }}>
          {key} 💩
        </strong>
        {JSON.stringify(val, '', ' ')}
      </pre>
    ))}
  </div>
);

export default Dump;
```
````

Ok, if we go to the [prism-react-renderer] GitHub page and copy the
example code into `root-wrapper.js` for the `pre` element.

We're going to copy the provided code for highlighting to validate it
works.

```jsx
import { MDXProvider } from '@mdx-js/react';
import Highlight, { defaultProps } from 'prism-react-renderer';
import React from 'react';

const components = {
  h2: ({ children }) => (
    <h2 style={{ color: 'rebeccapurple' }}>{children}</h2>
  ),
  'p.inlineCode': props => (
    <code style={{ backgroundColor: 'lightgray' }} {...props} />
  ),
  pre: props => (
    <Highlight
      {...defaultProps}
      code={`
        (function someDemo() {
          var test = "Hello World!";
          console.log(test);
        })();

        return () => <App />;
      `}
      language="jsx">
      {({
        className,
        style,
        tokens,
        getLineProps,
        getTokenProps,
      }) => (
        <pre className={className} style={style}>
          {tokens.map((line, i) => (
            <div {...getLineProps({ line, key: i })}>
              {line.map((token, key) => (
                <span {...getTokenProps({ token, key })} />
              ))}
            </div>
          ))}
        </pre>
      )}
    </Highlight>
  ),
};

export const wrapRootElement = ({ element }) => (
  <MDXProvider components={components}>{element}</MDXProvider>
);
```

Cool, cool! Now we want to replace the pasted in code example with the
props of the child component of the pre component, we can do that with
`props.children.props.children.trim()` 🙃.

```jsx
import { MDXProvider } from '@mdx-js/react';
import Highlight, { defaultProps } from 'prism-react-renderer';
import React from 'react';

const components = {
  pre: props => (
    <Highlight
      {...defaultProps}
      code={props.children.props.children.trim()}
      language="jsx">
      {({
        className,
        style,
        tokens,
        getLineProps,
        getTokenProps,
      }) => (
        <pre className={className} style={style}>
          {tokens.map((line, i) => (
            <div {...getLineProps({ line, key: i })}>
              {line.map((token, key) => (
                <span {...getTokenProps({ token, key })} />
              ))}
            </div>
          ))}
        </pre>
      )}
    </Highlight>
  ),
};

export const wrapRootElement = ({ element }) => (
  <MDXProvider components={components}>{element}</MDXProvider>
);
```

Then to match the language, for now we're going to add in a `matches`
function to match the language class assigned to the code block.

```jsx
import { MDXProvider } from '@mdx-js/react';
import Highlight, { defaultProps } from 'prism-react-renderer';
import React from 'react';

const components = {
  h2: ({ children }) => (
    <h2 style={{ color: 'rebeccapurple' }}>{children}</h2>
  ),
  'p.inlineCode': props => (
    <code style={{ backgroundColor: 'lightgray' }} {...props} />
  ),
  pre: props => {
    const className = props.children.props.className || '';
    const matches = className.match(/language-(?<lang>.*)/);
    return (
      <Highlight
        {...defaultProps}
        code={props.children.props.children.trim()}
        language={
          matches && matches.groups && matches.groups.lang
            ? matches.groups.lang
            : ''
        }>
        {({
          className,
          style,
          tokens,
          getLineProps,
          getTokenProps,
        }) => (
          <pre className={className} style={style}>
            {tokens.map((line, i) => (
              <div {...getLineProps({ line, key: i })}>
                {line.map((token, key) => (
                  <span {...getTokenProps({ token, key })} />
                ))}
              </div>
            ))}
          </pre>
        )}
      </Highlight>
    );
  },
};

export const wrapRootElement = ({ element }) => (
  <MDXProvider components={components}>{element}</MDXProvider>
);
```

[prism-react-renderer] comes with additional themes over the default
theme which is [duotoneDark] we're going to use [nightOwl] in this
example, feel free to take a look at [the other examples] if you like.

Import the `theme` then use it in the props of the `Highlight`
component.

```jsx
import { MDXProvider } from '@mdx-js/react';
import Highlight, { defaultProps } from 'prism-react-renderer';
import theme from 'prism-react-renderer/themes/nightOwl';
import React from 'react';

const components = {
  pre: props => {
    const className = props.children.props.className || '';
    const matches = className.match(/language-(?<lang>.*)/);

    return (
      <Highlight
        {...defaultProps}
        code={props.children.props.children.trim()}
        language={
          matches && matches.groups && matches.groups.lang
            ? matches.groups.lang
            : ''
        }
        theme={theme}>
        {({
          className,
          style,
          tokens,
          getLineProps,
          getTokenProps,
        }) => (
          <pre className={className} style={style}>
            {tokens.map((line, i) => (
              <div {...getLineProps({ line, key: i })}>
                {line.map((token, key) => (
                  <span {...getTokenProps({ token, key })} />
                ))}
              </div>
            ))}
          </pre>
        )}
      </Highlight>
    );
  },
};

export const wrapRootElement = ({ element }) => (
  <MDXProvider components={components}>{element}</MDXProvider>
);
```

Ok, now time to abstract this out into it's own component so our
`root-wrapper.js` isn't so crowded.

Make a `Code.js` component, move the code from `root-wrapper.js` into
there

```jsx
touch src/components/Code.js
```

Remember this?

> Cool, cool! Now we want to replace the pasted in code example with
> the props of the child component of the pre component, we can do
> that with `props.children.props.children.trim()` 🙃.

If that ☝ makes no real amount of sense for you (I've had to read it
many, many times myself), don't worry, now we're going to dig into
that a bit more for the creation of the code block component.

So, for now in the `components` we're adding into the `MDXProvider`
let's just take a look at the `props` coming into the `pre` element.

Comment out the code we added earlier and add in a `console.log`:

```js
pre: props => {
  console.log('=====================');
  console.log(props);
  console.log('=====================');
  return <pre />;
};
```

Now if we pop open the developer tools of your browser we can see the
output.

```
{children: {…}}
  children:
    $$typeof: Symbol(react.element)
    key: null
    props: {parentName: "pre", className: "language-jsx", originalType: "code", mdxType: "code", children: "import React from 'react'↵↵const Dump = props => (…  </pre>↵    ))}↵  </div>↵)↵↵export default Dump↵"}
    ref: null
    type: ƒ (re....
```

If we drill into the props of that output we can see the `children` of
those props, if you take a look at the contents of that you will see
that it is the code string for our code block, this is what we're
going to be passing into the `Code` component we're about to create.
Other properties to note here are the `className` and `mdxType`.

So, let's take the code we used earlier for `Highlight`, everything
inside and including the `return` statement and paste it into the
`Code.js` module we created earlier.

`Highlight` requires several props:

```jsx
<Highlight
  {...defaultProps}
  code={codeString}
  language={language}
  theme={theme}
>
```

The `Code` module should look something like this now:

```jsx
import Highlight, { defaultProps } from 'prism-react-renderer';
import theme from 'prism-react-renderer/themes/nightOwl';
import React from 'react';

const Code = ({ codeString, language }) => {
  return (
    <Highlight
      {...defaultProps}
      code={codeString}
      language={language}
      theme={theme}>
      {({
        className,
        style,
        tokens,
        getLineProps,
        getTokenProps,
      }) => (
        <pre className={className} style={style}>
          {tokens.map((line, i) => (
            <div {...getLineProps({ line, key: i })}>
              {line.map((token, key) => (
                <span {...getTokenProps({ token, key })} />
              ))}
            </div>
          ))}
        </pre>
      )}
    </Highlight>
  );
};

export default Code;
```

Back to the `root-wrapper` where we're going to pass the `props`
needed to the `Code` component.

The first check we're going to do is if the `mdxType` is `code` then
we can get the additional props we need to pass to our `Code`
component.

We're going to get `defaultProps` and the `theme` from
`prism-react-renderer` so all that's needed is the `code` and
`language`.

The `codeString` we can get from the `props`, `children` by
destructuring from the `props` being passed into the `pre` element.
The `language` can either be the tag assigned to the meta property of
the backticks, like `js`, `jsx` or equally empty, so we check for that
with some JavaScript and also remove the `language-` prefix, then pass
in the elements `{...props}`:

```jsx
pre: ({ children: { props } }) => {
  if (props.mdxType === 'code') {
    return (
      <Code
        codeString={props.children.trim()}
        language={
          props.className && props.className.replace('language-', '')
        }
        {...props}
      />
    );
  }
};
```

Ok, now we're back to where we were before abstracting out the
`Highlight` component to it's own module. Let's add some additional
styles with `styled-components` and replace the `pre` with a styled
`Pre` and we can also add in some line numbers with a styled span and
style that as well.

```js
import Highlight, { defaultProps } from 'prism-react-renderer';
import theme from 'prism-react-renderer/themes/nightOwl';
import React from 'react';
import styled from 'styled-components';

export const Pre = styled.pre`
  text-align: left;
  margin: 1em 0;
  padding: 0.5em;
  overflow-x: auto;
  border-radius: 3px;

  & .token-line {
    line-height: 1.3em;
    height: 1.3em;
  }
  font-family: 'Courier New', Courier, monospace;
`;

export const LineNo = styled.span`
  display: inline-block;
  width: 2em;
  user-select: none;
  opacity: 0.3;
`;

const Code = ({ codeString, language, ...props }) => {
  return (
    <Highlight
      {...defaultProps}
      code={codeString}
      language={language}
      theme={theme}>
      {({
        className,
        style,
        tokens,
        getLineProps,
        getTokenProps,
      }) => (
        <Pre className={className} style={style}>
          {tokens.map((line, i) => (
            <div {...getLineProps({ line, key: i })}>
              <LineNo>{i + 1}</LineNo>
              {line.map((token, key) => (
                <span {...getTokenProps({ token, key })} />
              ))}
            </div>
          ))}
        </Pre>
      )}
    </Highlight>
  );
};

export default Code;
```

### Copy code to clipboard

What if we had some way of getting that props code string into the
clipboard?

I had a look around and found the majority of the components available
for this sort of thing expected an input until [this] in the Gatsby
source code. Which is creating the input for you 👌

So, let's create a `utils` directory and the `copy-to-clipboard.js`
file and add in the code from the Gatsby sourcue code.

```bash
mkdir src/utils
touch src/utils/copy-to-clipboard.js
```

```js
// https://github.com/gatsbyjs/gatsby/blob/master/www/src/utils/copy-to-clipboard.js

export const copyToClipboard = str => {
  const clipboard = window.navigator.clipboard;
  /*
   * fallback to older browsers (including Safari)
   * if clipboard API not supported
   */
  if (!clipboard || typeof clipboard.writeText !== `function`) {
    const textarea = document.createElement(`textarea`);
    textarea.value = str;
    textarea.setAttribute(`readonly`, true);
    textarea.setAttribute(`contenteditable`, true);
    textarea.style.position = `absolute`;
    textarea.style.left = `-9999px`;
    document.body.appendChild(textarea);
    textarea.select();
    const range = document.createRange();
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    textarea.setSelectionRange(0, textarea.value.length);
    document.execCommand(`copy`);
    document.body.removeChild(textarea);

    return Promise.resolve(true);
  }

  return clipboard.writeText(str);
};
```

Now we're going to want a way to trigger copying the code to the
clipboard.

Lets create a styled button but first add a `position: relative;` to
the `Pre` component which will let us position the styled button:

```js
const CopyCode = styled.button`
  position: absolute;
  right: 0.25rem;
  border: 0;
  border-radius: 3px;
  margin: 0.25em;
  opacity: 0.3;
  &:hover {
    opacity: 1;
  }
`;
```

And now we need to use the `copyToClipboard` function in the `onClick`
of the button:

```jsx
import Highlight, { defaultProps } from 'prism-react-renderer';
import theme from 'prism-react-renderer/themes/nightOwl';
import React from 'react';
import styled from 'styled-components';
import { copyToClipboard } from '../utils/copy-to-clipboard';

export const Pre = styled.pre`
  text-align: left;
  margin: 1rem 0;
  padding: 0.5rem;
  overflow-x: auto;
  border-radius: 3px;

  & .token-line {
    line-height: 1.3rem;
    height: 1.3rem;
  }
  font-family: 'Courier New', Courier, monospace;
  position: relative;
`;

export const LineNo = styled.span`
  display: inline-block;
  width: 2rem;
  user-select: none;
  opacity: 0.3;
`;

const CopyCode = styled.button`
  position: absolute;
  right: 0.25rem;
  border: 0;
  border-radius: 3px;
  margin: 0.25em;
  opacity: 0.3;
  &:hover {
    opacity: 1;
  }
`;

const Code = ({ codeString, language }) => {
  const handleClick = () => {
    copyToClipboard(codeString);
  };

  return (
    <Highlight
      {...defaultProps}
      code={codeString}
      language={language}
      theme={theme}>
      {({
        className,
        style,
        tokens,
        getLineProps,
        getTokenProps,
      }) => (
        <Pre className={className} style={style}>
          <CopyCode onClick={handleClick}>Copy</CopyCode>
          {tokens.map((line, i) => (
            <div {...getLineProps({ line, key: i })}>
              <LineNo>{i + 1}</LineNo>
              {line.map((token, key) => (
                <span {...getTokenProps({ token, key })} />
              ))}
            </div>
          ))}
        </Pre>
      )}
    </Highlight>
  );
};

export default Code;
```

## React live

So with React Live we need to add two snippets to our `Code.js`
component.

We're going to import the components:

```jsx
import {
  LiveEditor,
  LiveError,
  LivePreview,
  LiveProvider,
} from 'react-live';
```

Then we're going to check if `react-live` has been added to the
language tag on our mdx file via the props:

```jsx
if (props['react-live']) {
  return (
    <LiveProvider code={codeString} noInline={true} theme={theme}>
      <LiveEditor />
      <LiveError />
      <LivePreview />
    </LiveProvider>
  );
}
```

To test this, let's add `react-live` next to the language on our
`Dump` component:

````text
```jsx react live
````

- Now react-live
- Create elements folder

```bash
mkdir -p src/components/elements
touch src/components/elements/Code.js
```

- Customizing Components:
  [https://www.gatsbyjs.org/docs/mdx/customizing-components/](https://www.gatsbyjs.org/docs/mdx/customizing-components/)

## Cover Image

## i11n

- [https://github.com/gatsbyjs/gatsby/tree/master/examples/using-i18n](https://github.com/gatsbyjs/gatsby/tree/master/examples/using-i18n)

## SEO

- this helped me for my own blog:
  [https://juliangaramendy.dev/custom-open-graph-images-in-gatsby-blog/](https://juliangaramendy.dev/custom-open-graph-images-in-gatsby-blog/)
- [https://www.heymeta.com/](https://www.heymeta.com/)
- [https://opengraphcheck.com/](https://opengraphcheck.com/)
- [https://cards-dev.twitter.com/validator](https://cards-dev.twitter.com/validator)
- [https://developers.facebook.com/tools/debug/sharing](https://developers.facebook.com/tools/debug/sharing)

## Commenting

- [https://github.com/utterance/utterances](https://github.com/utterance/utterances)

## Links

[https://www.gatsbyjs.org/packages/gatsby-plugin-mdx/](https://www.gatsbyjs.org/packages/gatsby-plugin-mdx/)
[site metadata]:
https://www.gatsbyjs.org/docs/gatsby-config/#sitemetadata [react
helmet]: https://www.gatsbyjs.org/packages/gatsby-plugin-react-helmet/
[mdx layouts]:
https://gatsby-mdx.netlify.com/api-reference/options/default-layouts/

<!-- Links -->

[windows web-dev bootstrap]:
  http://blog.scottspence.me/wsl-bootstrap-2019
[ubuntu as well]: https://www.youtube.com/watch?v=eSAsdQuQ-1o
[codesandbox.io]: https://codesandbox.io
[gatsby-source-filesystem]:
  https://www.gatsbyjs.org/packages/gatsby-source-filesystem/
[gatsby-plugin-mdx]:
  https://www.gatsbyjs.org/packages/gatsby-plugin-mdx/
[v0 may 2017]:
  https://github.com/spences10/blog.scottspence.me/tree/a470e8563e1a040527cf2094fc1b377550a88c77
[progressive disclosure of complexity]:
  https://lengstorf.com/progressive-disclosure-of-complexity/
[layout components]: https://www.gatsbyjs.org/docs/layout-components/
[dump.js]: https://github.com/wesbos/dump
[prism-react-renderer]:
  https://github.com/FormidableLabs/prism-react-renderer
[react-live]: https://github.com/FormidableLabs/react-live
[egghead.io playlist]:
  https://egghead.io/lessons/vue-js-introduction-to-mdx?pl=building-websites-with-mdx-and-gatsby-161e9529
[chris biscardi]: https://twitter.com/chrisbiscardi
[duotonedark]:
  https://github.com/FormidableLabs/prism-react-renderer/blob/master/themes/duotoneDark.js
[nightowl]:
  https://github.com/FormidableLabs/prism-react-renderer/blob/master/themes/nightOwl.js
[the other examples]:
  https://github.com/FormidableLabs/prism-react-renderer/blob/master/themes
[this]:
  https://github.com/gatsbyjs/gatsby/blob/master/www/src/utils/copy-to-clipboard.js
